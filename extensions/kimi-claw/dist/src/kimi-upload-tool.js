import{constants}from"node:fs";import{access,readFile,stat}from"node:fs/promises";import{basename,extname}from"node:path";import{DEFAULT_KIMIAPI_HOST}from"./acp-gateway-bridge.js";import{asTrimmedNonEmptyString}from"./utils/text.js";export const KIMI_UPLOAD_TOOL_NAME="kimi_upload_file";const KIMI_UPLOAD_TOOL_SCHEMA_TITLE="Kimi file upload",KIMI_UPLOAD_TOOL_SCHEMA_DESCRIPTION="Upload local files from this machine to the current Kimi conversation. If the call succeeds, the files are already sent to the user in Kimi and no additional send tool is needed.",KIMI_UPLOAD_TOOL_PATHS_DESCRIPTION="Local filesystem paths only (1-5 total). Any file type is accepted, including text, images, documents, PDFs, archives, and binary files. Use absolute or workspace-relative local paths that are readable files.",MAX_PATHS=5,MIN_PATHS=1;export const KIMI_UPLOAD_TOOL_SCHEMA={title:"Kimi file upload",type:"object",description:KIMI_UPLOAD_TOOL_SCHEMA_DESCRIPTION,additionalProperties:!1,required:["paths"],properties:{paths:{type:"array",minItems:1,maxItems:5,description:KIMI_UPLOAD_TOOL_PATHS_DESCRIPTION,items:{type:"string",minLength:1,description:"Single local filesystem path only, e.g., /Users/name/project/a.pdf or ./relative/path/binary.bin"}}}};export const KIMI_UPLOAD_TOOL_MAX_PATHS=5;export const KIMI_UPLOAD_TOOL_MIN_PATHS=1;export const KIMI_UPLOAD_TOOL_MAX_CONCURRENCY=3;export const KIMI_FILE_UPLOAD_PATH="/files:upload";const KIMI_UPLOAD_TOOL_REQUEST_TIMEOUT_MS=12e4,KIMI_UPLOAD_TOOL_FILE_HEADER="X-Kimi-Bot-Token";export const resolveKimiUploadEndpoint=(e=DEFAULT_KIMIAPI_HOST)=>{const t=e.trim();return t?t.endsWith("/files:upload")?t:`${t.endsWith("/")?t.slice(0,-1):t}/files:upload`:`${DEFAULT_KIMIAPI_HOST}/files:upload`};const INVALID_PARAMS={code:-32602,message:"invalid params"};export const KIMI_UPLOAD_VALIDATION_MESSAGE=INVALID_PARAMS.message;const invalid=(e,t)=>({ok:!1,error:{...INVALID_PARAMS,data:{field:e,reason:t}}}),isRecord=e=>!!e&&"object"==typeof e&&!Array.isArray(e),parsePath=e=>{const t=asTrimmedNonEmptyString(e);if(t)return t},DEFAULT_FS={access:(e,t)=>access(e,t),stat:e=>stat(e),readFile:e=>readFile(e)},DEFAULT_HTTP={fetch:(e,t)=>globalThis.fetch(e,t)},normalizeConcurrency=e=>!e||e<1?1:e,normalizeRequestTimeoutMs=e=>"number"!=typeof e||!Number.isFinite(e)||e<=0?12e4:Math.trunc(e),runWithConcurrency=async(e,t,a)=>{if(0===e.length)return[];const r=Math.min(normalizeConcurrency(t),e.length),i=new Array(e.length);let n=0;const s=Array.from({length:r},()=>(async()=>{for(;;){const t=n;if(n+=1,t>=e.length)return;i[t]=await a(e[t],t)}})());return await Promise.all(s),i},fsDependencyFromOptions=e=>({access:e?.fs?.access??DEFAULT_FS.access,stat:e?.fs?.stat??DEFAULT_FS.stat,readFile:e?.fs?.readFile??DEFAULT_FS.readFile}),httpDependencyFromOptions=e=>({fetch:e?.transport?.fetch??e?.fetch??DEFAULT_HTTP.fetch}),inferMimeTypeFromFileName=e=>{switch(extname(e).toLowerCase()){case".txt":return"text/plain";case".md":return"text/markdown";case".json":return"application/json";case".html":return"text/html";case".css":return"text/css";case".js":case".mjs":case".cjs":return"text/javascript";case".ts":return"text/x.typescript";case".tsx":case".jsx":return"text/jsx";case".xml":return"application/xml";case".yaml":case".yml":return"application/yaml";case".toml":return"application/toml";case".pdf":return"application/pdf";case".png":return"image/png";case".jpg":case".jpeg":return"image/jpeg";case".gif":return"image/gif";case".webp":return"image/webp";case".svg":return"image/svg+xml";case".csv":return"text/csv";case".zip":return"application/zip";default:return"application/octet-stream"}},isRecordObject=e=>isRecord(e),parseUploadedFile=(e,t,a)=>{if(!isRecordObject(e))return invalid("paths",`upload response at index ${t} is invalid`);const r=e.file;if(!isRecordObject(r))return invalid("paths",`upload response at index ${t} missing file object`);const i=parsePath(r.id),n=isRecordObject(r.meta)?r.meta:void 0,s=parsePath(n?.name)||a.fileName,o=parsePath(n?.contentType)||parsePath(n?.content_type)||a.contentType;return i?{ok:!0,value:{uri:`kimi-file://${i}`,name:s,mimeType:o}}:invalid("paths",`upload response at index ${t} missing file.id`)},uploadKimiFile=async(e,t,a,r,i,n,s)=>{const o=await n.readFile(e.path),l=new FormData;l.append("file",new Blob([o],{type:e.contentType}),e.fileName);const c=new AbortController,p=setTimeout(()=>{c.abort()},i);let d,m;p.unref?.();try{d=await s.fetch(a,{method:"POST",body:l,headers:{[KIMI_UPLOAD_TOOL_FILE_HEADER]:r},signal:c.signal})}catch(t){if("AbortError"===(t instanceof Error?t.name:""))throw new Error(`upload timed out for ${e.path} after ${i}ms`);throw t}finally{clearTimeout(p)}if(!d.ok){let t="";try{t=await d.text()}catch{t=d.statusText}throw new Error(`upload failed for ${e.path}: ${d.status} ${t}`.trim())}try{m=await d.json()}catch{throw new Error(`upload failed for ${e.path}: invalid JSON response`)}const u=parseUploadedFile(m,t,e);if(!u.ok)throw new Error(`upload failed for ${e.path}: ${u.error.data.reason}`);return u.value};export const uploadKimiFilesToKimiEndpoint=async(e,t={})=>{const a=fsDependencyFromOptions(t),r=httpDependencyFromOptions(t),i=normalizeRequestTimeoutMs(t.requestTimeoutMs),n=t.uploadUrl??resolveKimiUploadEndpoint();if(!n||"string"!=typeof n||!n.trim())return invalid("paths","upload endpoint is required");const s=t.botToken;if(!s||"string"!=typeof s||!s.trim())return invalid("paths","bot token is required");const o=await uploadKimiFilesWithConcurrency(e,(e,t)=>uploadKimiFile(e,t,n,s,i,a,r),t);return o.ok?{ok:!0,files:o.value}:o};const toErrorReason=e=>{if(!(e instanceof Error))return"must be readable";const t=e.code;return"ENOENT"===t||"ENOTDIR"===t?"must exist":"must be readable"},validateLocalUploadPath=async(e,t,a)=>{try{await a.access(e,constants.R_OK)}catch(e){return invalid(`paths[${t}]`,toErrorReason(e))}let r;try{r=await a.stat(e)}catch(e){return invalid(`paths[${t}]`,toErrorReason(e))}return!r.isFile()||r.isDirectory()?invalid(`paths[${t}]`,"must be a regular file"):{ok:!0,value:{path:e,fileName:basename(e),contentType:inferMimeTypeFromFileName(e)}}},isValidationFailure=e=>!e.ok;export const validateKimiUploadLocalFiles=async(e,t={})=>{const a=fsDependencyFromOptions(t),r=await runWithConcurrency(e,t.maxConcurrency??3,(e,t)=>validateLocalUploadPath(e,t,a));return r.find(isValidationFailure)||{ok:!0,value:r.map(e=>e.value)}};export const uploadKimiFilesWithConcurrency=async(e,t,a={})=>{const r=await validateKimiUploadLocalFiles(e,a);if(!r.ok)return r;try{return{ok:!0,value:await runWithConcurrency(r.value,a.maxConcurrency??3,(e,a)=>t(e,a))}}catch(e){return invalid("paths",`upload failed: ${e instanceof Error?e.message:"unknown error"}`)}};export const parseKimiUploadToolParams=e=>{if(!isRecord(e))return invalid("params","must be an object");if(Object.keys(e).filter(e=>"paths"!==e).length>0)return invalid("paths","only paths is allowed");if(!Object.prototype.hasOwnProperty.call(e,"paths"))return invalid("paths","is required");const t=e.paths;if(!Array.isArray(t))return invalid("paths","must be an array");if(t.length<1)return invalid("paths","must contain at least 1 item");if(t.length>5)return invalid("paths","must contain no more than 5 items");const a=[];for(let e=0;e<t.length;e+=1){const r=parsePath(t[e]);if(!r)return invalid(`paths[${e}]`,"must be a non-empty string");a.push(r)}return{ok:!0,value:{paths:a}}};